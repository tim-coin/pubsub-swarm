
// var sodium = require('chloride')
var crypto = require('crypto')

//  var scalarmult = sodium.crypto_scalarmult
//  var box  = sodium.crypto_box_easy
//  var secretbox = sodium.crypto_secretbox_easy
//  var secretbox_open = sodium.crypto_secretbox_open_easy
//  var keypair = sodium.crypto_box_keypair
var concat = Buffer.concat

var scalarmult = crypto.computeSecret
var secretbox = crypto.createCipheriv
var secretbox_open = crypto.createDecipheriv
var keypair = crypto.generateKeys
var encoding = 'hex'
var ed = require("./endec")
const ecdh = crypto.createECDH('secp256k1');

function randombytes(n) {
  // var b = new Buffer(n)
  // sodium.randombytes(b)
  return crypto.randomBytes(n)
}

function setMax (m) {
  m = m || DEFAULT_MAX
  if (m < 1 || m > 255)
    throw new Error('max recipients must be between 0 and 255.')
  return m
}


const DEFAULT_MAX = 7
const PUBKEY_LEN = 65

exports.encrypt =
exports.multibox = function (msg, recipients, max) {

  max = setMax(max)

  if(recipients.length > max)
    throw new Error('max recipients is:'+max+' found:'+recipients.length)

  var nonce = crypto.randomBytes(16)  //  randombytes(12)
  var key = randombytes(32) //.toString('hex')
  //let key = Buffer.from(keysp.substring(0, 32), "binary") //  buffer from binary string.
  //console.log("==16==>", key.length)
  var onetime = crypto.createECDH('secp256k1') // keypair()
  onetime.generateKeys()

  var _key = concat([new Buffer([recipients.length & max]), key])

  /*
  let cipher0 = crypto.createCipheriv('aes-192-ccm', key , nonce)
  let enc0 = cipher0.update(msg, 'utf8', 'hex' )
  enc0 += cipher0.final('hex')
  */
  var enc0 = ed.encrypt(msg,key,nonce )
  console.log("==PubK32?==>" , _key.length, onetime.getPublicKey().length )
  var mbox = Buffer.from(enc0, 'hex')
  //console.log("MainBOXZ: " ,mbox.toString('hex'),mbox.length, msg )

  return concat([
    nonce,
    onetime.getPublicKey(),
    concat(recipients.map(function (r_pk, i) {
      var ots = onetime.computeSecret( r_pk).toString('hex').substring(0,32)
      //console.log("=Share Key Len=> ", ots, nonce )
      /*
      let cipher = crypto.createCipheriv('aes-192-ccm', ots , nonce)
      let enc = cipher.update(_key, 'utf8', 'hex');
      enc += cipher.final('hex')
      */
      //console.log(i,"Concat Test1: ", _key, _key.toString('utf8').length , _key.toString('hex') , typeof nonce)

      var enc = ed.encrypt(_key.toString('hex'), ots, nonce)
      //var enc = crypto.publicEncrypt(r_pk, _key)
      //console.log(i, "==##==>", enc.length ,  enc.toString('hex'), typeof enc, Buffer.from(enc, 'utf8'), Buffer.from(enc).toString().length )
      var scbx = Buffer.from(enc, 'hex')
      console.log(i, "SOLBOXZ: " ,scbx.length )
      return scbx   // enc.toString("binary")
      //return secretbox(_key, nonce, onetime.computeSecret( r_pk))

    })),
    Buffer.from(enc0, 'hex') //  cipher0.final()
    //secretbox(msg, nonce, key)
  ])
}

function get_key(ctxt, my_key) {

}


exports.multibox_open_key = function (ctxt, sk, max) { //, groups...

  max = setMax(max)

  var nonce = ctxt.slice(0, 16)
  var onetime_pk = ctxt.slice(16, 16+PUBKEY_LEN)
  var myid = crypto.createECDH('secp256k1')
  myid.setPrivateKey(sk)

  var shr_key = myid.computeSecret(onetime_pk).toString('hex').substring(0,32)

  //var my_key = scalarmult(sk, onetime_pk)
  var _key, key, length, start = 16+PUBKEY_LEN, size = 80
  for(var i = 0; i <= max; i++) {
    var s = start+size*i
    if(s + size > (ctxt.length )) continue
    decstr = ctxt.slice(s, s+size)
    var _key = ed.decrypt(decstr, shr_key, nonce)

    if(_key) {
      length = _key.slice(0,2)
      length = parseInt(length, 16)
      key = _key.slice(2)
      if(  key.length == 64 && !containsNonLatinCodepoints(_key.toString('utf8')) ){
        return _key
      }else{
        continue
      }
    }
  }
  return
}

exports.multibox_open_body = function (ctxt, _key) { //, groups...
  if(!_key) return
  var length = _key.slice(0,2)
  length = parseInt(length, 16)
  var key = _key.slice(2)
  var start = 16+PUBKEY_LEN, size = 80
  var nonce = ctxt.slice(0, 16)
  var _msg = ed.decrypt(ctxt.slice(start+length*size),utf2bytearr(key), new Buffer(nonce) )
  return Buffer.from(_msg, 'utf8')
  //secretbox_open(ctxt.slice(start+length*size), nonce, key)
}


exports.decrypt =
exports.multibox_open = function (ctxt, sk, max) { //, groups...
  var _key = exports.multibox_open_key(ctxt, sk, max)
  if(_key) return exports.multibox_open_body(ctxt, _key)
}
exports.multibox_open2 = function (ctxt, sk, max) { //, groups...

  max = setMax(max)

  var nonce = ctxt.slice(0, 16)
  var onetime_pk = ctxt.slice(16, 16+PUBKEY_LEN)
  var myid = crypto.createECDH('secp256k1')
  myid.setPrivateKey(sk)

  //console.log("==32==>", onetime_pk.length, nonce)


  //var my_key = scalarmult(sk, onetime_pk)
  var shr_key = myid.computeSecret(onetime_pk).toString('hex').substring(0,32)
  var _key, key=false, length = 0, start = 16+PUBKEY_LEN, size = 80

  for(var i = 0; i <= max; i++) {
    var s = start+size*i
    if(s + size > (ctxt.length )) continue
    decstr = ctxt.slice(s, s+size)
    //_key = secretbox_open(ctxt.slice(s, s + size), nonce, my_key)
    /*
    let decipher = crypto.createDecipheriv('aes-192-ccm', shr_key , nonce)
    console.log("==CTXS==>", decstr.length ,decstr.toString('utf8'),decstr.length , decstr.toString('utf8').toString('hex').length )
    let _key = decipher.update(decstr.toString('utf8').toString('hex') , 'hex', 'utf8');
    _key += decipher.final('utf8')
    */
    var _key = ed.decrypt(decstr, shr_key, nonce)
    //decrypted = _key.substr(0, _key.length - _key.charCodeAt(_key.length - 1));

    if(_key) {
      //console.log("T126:")
      length = _key.slice(0,2)
      length = parseInt(length, 16)
      key = _key.slice(2)
      //console.log(i, "CHKPT: KEYLEN: ",(key).length)

      // utf2bytearr(key).length == 32 && typeof length == "number" && !isNaN(length) &&
      if(  key.length == 64 && !containsNonLatinCodepoints(_key.toString('utf8')) ){
        console.log(i, "Concat Test2: ",_key.length,  _key.toString('hex'), containsNonLatinCodepoints(_key.toString('utf8')) )

        break
      }else{
        //console.log("Not good chunk")
        continue
      }
    }
    //start = start  + size
  }
  console.log("Len: Alice + Bob = 2 ?", length.toString(), length == max)
  //if(!key) return
  if(utf2bytearr(key).length != 32 || key.length != 64)  return

  //var key1 = Buffer(key,"utf8").toString('hex') //.replace(/[0x0]/,'')

  /*
  while(key1.substr(-1) == 0x0){
    //console.log("0X0: ", key1.substr(-1), key1.length, key1)
    key1 = key1.replace(/0/,'')
    key1 = key1.replace(/0([^0]*)$/,'')
  }
  */
  //var key2 = Buffer(key, "hex").toString('utf8').trim()


  var byt = utf2bytearr(key)

  //byt.copy(key3)
  //var str = byt.toString('hex')
  //console.log(":>> ","c7 >",";" ,   byt )
  //key3 = Buffer(key3, 'utf8')
  //  var tstr = 'a4d663569017f08882fe193a224c1049d33747617fd19511d81528be7ef6b1fb'
  //console.log("Key: ", untag(byt), untag(byt).length , byt.length,"\n",  byt.toString() ) // , tstr.length)

  var _msg = ed.decrypt(ctxt.slice(start+length*size),byt, new Buffer(nonce) )
  /*
  let decipher0 = crypto.createDecipheriv('aes-192-ccm', key , nonce)
  let _msg = decipher0.update(key, 'utf8', 'hex');
  _msg += decipher0.final('hex')
  */
  console.log("MSG: ", _msg)
  return Buffer.from(_msg, 'utf8') //.toString("utf8") // Buffer.from(_msg, 'hex')
  //return secretbox_open(ctxt.slice(start+length*size), nonce, key)
}


function isDoubleByte(str) {
    for (var i = 0, n = str.length; i < n; i++) {
        if (str.charCodeAt( i ) > 255) { return true; }
    }
    return false;
}

function containsNonLatinCodepoints(s) {
    return /[^\u0000-\u00ff]/.test(s);
}

function untag(stbf){
  for(var i = stbf.length; i > 0; i--){

    if(stbf[i] == 0){
      //console.log(i, key3[i], key3[i], key3[i] == 0 )
      stbf = stbf.slice(0,i)
    }
  }
  return stbf
}

function utf2bytearr(key){
  //console.log("T: ", key.length)
  var byt = randombytes(32)
  keystr = key.toString()
  for (var i = 0; i < byt.length; i ++) {
    //a.push("0x" + str.substr(i, 2));
    //console.log(keystr.substr(i*2,2) )
    byt[i] = parseInt(keystr.substr(i*2,2), 16)
  }
  return byt
}
