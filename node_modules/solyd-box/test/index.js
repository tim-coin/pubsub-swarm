
var tape = require('tape')
var crypto = require('crypto')

var c = require('../')
// var sodium = require('chloride/build/Release/sodium')

//  var keypair = sodium.crypto_box_keypair
//var keypair = crypto.generateKeys

//var alice = keypair()
var alice = crypto.createECDH('secp256k1')
alice.generateKeys()
var bob   = crypto.createECDH('secp256k1')
bob.generateKeys()
var jane   = crypto.createECDH('secp256k1')
jane.generateKeys()

function arrayOfSize (n) {
  return new Array(n+1).join('0').split('')
}

tape('simple', function (t) {
  //console.log(">>", alice.getPublicKey() )
  var msg = new Buffer('1 there ksjfhsdf sdfu sdfiusdf sdfs dfsjdf sdfgsd fjsgdf sjdfg sdjfgs djfgsd jfsjdfg sdjfgh!')
  keysmap = []
  keysmap.push(alice.getPublicKey())
  keysmap.push(bob.getPublicKey())
  keysmap.push(jane.getPublicKey())
  shane = keypair()
  keysmap.push(shane.getPublicKey() )
  console.log()

  var ctxt = c.multibox(msg, keysmap)
  //console.log("==~~~==> ", ctxt.toString('hex').length)
  keysmaps = []
  keysmaps.push(alice.getPrivateKey())
  keysmaps.push(bob.getPrivateKey())
  keysmaps.push(jane.getPrivateKey())
  keysmaps.push(shane.getPrivateKey()  )
  // ;[alice.getPrivateKey(), bob.getPrivateKey(), jane.getPrivateKey() ]
  keysmaps.forEach(function (sk) {

    console.log("==--=> ", sk.length, ctxt.length)
    var _msg = c.multibox_open(ctxt, sk)
    //console.log("EQ? ", msg, _msg)
    t.deepEqual(_msg, msg)

  })

  t.end()
})

tape('errors when too many recipients', function (t) {
  var msg = new Buffer('hello there!')
  var pk = alice.getPublicKey()
  t.throws(function () {
      c.multibox(msg, [
        pk,pk,pk,pk,
        pk,pk,pk,pk,
        pk,pk,pk,pk,
        pk,pk,pk,pk
      ])
  })
  t.end()
})

function keypair(){
  var alice = crypto.createECDH('secp256k1')
  alice.generateKeys()
  return alice
}

function encryptDecryptTo (n, t) {
  //console.log("A: ", arrayOfSize(4) )
  //var ta = arrayOfSize(n).map(function () {return  7; })
  //console.log("A: ", ta )

  //var msg = crypto.randomBytes(1024)
  var msg = new Buffer('how are things going on in crypto. It is pretty amazing to see 1/4th of people confusing bitcoin`s money feature as real money !')

  var keys = arrayOfSize(n).map(function () { return keypair(); })
  console.log("------------------------------------")
  var keysmap = []
  for(var i = 0; i < n; i++){
    keysmap.push(keys[i].getPublicKey() )
    //console.log("PKEY: ", keys[i].getPublicKey(), keys[i].getPublicKey().length)
  }
  //keysmaps = [keypair().getPublicKey(),keypair().getPublicKey(),keypair().getPublicKey(),keypair().getPublicKey(),keypair().getPublicKey() ]
  //var ctxt = c.multibox(msg, keys.map(function (e) { return e.getPublicKey() }), n)
  var ctxt = c.multibox(msg, keysmap, n)
  console.log("===>>>==>", ctxt)
  // a recipient key may open the message.
  keys.forEach(function (key) {
    console.log(key.getPrivateKey().length, ctxt.length)
    t.deepEqual(c.multibox_open(ctxt, key.getPrivateKey(), n), msg)
  })

  t.equal(c.multibox_open(ctxt, keypair().getPrivateKey() ), undefined)
}

console.log("===>>>=======================>")


tape('with no custom max set, encrypt/decrypt to 7 keys', function (t) {
  encryptDecryptTo(7, t)
  t.end()
})


tape('can encrypt/decrypt up to 255 recipients after setting a custom max', function (t) {
  encryptDecryptTo(255, t)
  t.end()
})


tape('errors when max is more than 255 or less than 1', function (t) {
  var msg = new Buffer('hello there!')
  var ctxt = c.multibox(msg, [alice.getPublicKey(), bob.getPublicKey()])
  var pk = alice.getPublicKey()
  var sk = alice.getPrivateKey()
  t.throws(function () {
      c.multibox(msg, [
        pk,pk,pk,pk,
      ], -1)
  })
  t.throws(function () {
      c.multibox_open(ctxt, sk, 256)
  })
  t.end()
})
